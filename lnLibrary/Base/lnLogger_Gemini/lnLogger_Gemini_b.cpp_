/*
// updated by ...: Loreto Notarantonio
// Date .........: 15-07-2025 11.35.25
*/



#include <Arduino.h>



class ESP32Logger {
    public:

        /**
         * @brief Genera un timestamp formattato (HH:MM:SS.mmm) usando esp_timer_get_time().
         * @return Una stringa costante contenente il timestamp.
         */
        static const char* getTimestamp() {
            m_us = esp_timer_get_time(); // Tempo in microsecondi dall'avvio
            m_ms = (us / 1000) % 1000;
            m_s  = (us / 1000000) % 60;
            m_m  = (us / 60000000) % 60;
            m_h  = (us / 3600000000);

            snprintf(m_tbuf, sizeof(m_tbuf), "%02lu:%02lu:%02lu.%03lu", h, m, s, ms);
            return m_tbuf;
        }




        static const char* getFileLineInfo(const char* file, int line) {
            m_filename = strrchr(file, '/');
            m_filename = m_filename ? m_filename + 1 : file;

            m_sep = strrchr(m_filename, '_');
            if (!m_sep) m_sep = strrchr(m_filename, '.');

            size_t len = m_sep ? (size_t)(m_sep - m_filename) : strlen(m_filename);


            char name_buffer[maxlen + 1];
            if (len > maxlen) len = maxlen;

            memset(name_buffer, '.', maxlen);
            memcpy(name_buffer, filename, len);
            name_buffer[maxlen] = '\0';

            snprintf(out, sizeof(out), "%s.%03d", name_buffer, line);
            return out;
        }

        // Questa Ã¨ l'UNICA funzione pubblica/statica che viene chiamata dalle macro
        // Gestisce la formattazione e l'output.
        static void _log_write(const char* color, const char* tag, const char* file, int line, const char* format, ...) {
            char buffer[256]; // Buffer per il messaggio formattato
            va_list args;
            va_start(args, format);
            int len = vsnprintf(buffer, sizeof(buffer), format, args);
            va_end(args);

            if (len >= sizeof(buffer)) {
                buffer[sizeof(buffer) - 1] = '\0';
            }

            Serial.printf("%s[%s][%s][%s] %s%s\n",
                          color,
                          getTimestamp(),
                          getFileLineInfo(file, line),
                          tag,
                          buffer,
                          LogColors::RESET);
        }
};