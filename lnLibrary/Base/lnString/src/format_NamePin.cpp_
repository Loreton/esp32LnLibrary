/*
// updated by ...: Loreto Notarantonio
// Date .........: 29-06-2025 10.57.31
*/

// ---------------------------------
// lnLibrary headers files
// ---------------------------------
#define LOG_LEVEL_0x
#define LOG_LEVEL_99
#include "@globalVars.h"


#if 0
tirati da chat GPT
/**
    Scope:
        prendere una fullpath_filename ed un integer (line_nr)
        rimuove il path e l'extensiondal filename
        li inserisce in un buffer di lunghezza predefinita MAXLENGTH
        Il nome (name) può essere troncato a destra per farci stare comunque il .[XX]: con line_nr.
        result: [filename.99]

    Esempio di output:
        name        pin     Output (buffer)
        "abc"       15      [abc.15]
        "abcdefgh"  3       [abcdefg.03]
        "longnameX" 99      [longnam.99]

    Funziona anche se:
        Il path non ha / (usa tutto)
        Il file non ha estensione (usa tutto)
        Il nome è più lungo dello spazio disponibile (viene troncato)
*/
void formatFnameLine(char buffer[], int MAXLENGTH, const char *path, int line, bool padding) {
    // Estrai il nome file senza path
    const char *basename = strrchr(path, '/');
    basename = (basename) ? basename + 1 : path;  // se non c'è '/', usa tutto

    // Rimuovi estensione (se presente)
    size_t len = strcspn(basename, ".");  // lunghezza fino al primo '.'

    int pinLen = snprintf(NULL, 0, ".%02d]", line);
    // size_t nameMaxLen = (MAXLENGTH > (size_t)(pinLen + 1)) ? (MAXLENGTH - (pinLen + 1)) : 0;
    size_t nameMaxLen = (MAXLENGTH > (size_t)(pinLen)) ? (MAXLENGTH - (pinLen )) : 0;
    if (padding) {
        snprintf(buffer, MAXLENGTH, "[%-*.*s.%02d]", (int)nameMaxLen, (int)((len < nameMaxLen) ? len : nameMaxLen), basename, line);
    } else {
        snprintf(buffer, MAXLENGTH, "[%.*s.%02d]", (int)((len < nameMaxLen) ? len : nameMaxLen), basename, line);

    }
    // Costruzione stringa finale con trunc+padding

}

/**
    Scope:
        prendere una strings ed un integer (pin_nr)
        li inserisce in un buffer di lunghezza predefinita MAXLENGTH
        Il nome (name) può essere troncato a destra per farci stare comunque il .[XX]: con pin.
        result: [name_string.99]

    Esempio di output:
        name        pin     Output (buffer)
        "abc"       15      [abc.15]
        "abcdefgh"  3       [abcdefg.03]
        "longnameX" 99      [longnam.99]
[123456789
.67]
*/
void formatNamePin(char buffer[], int MAXLENGTH, const char *name, int pin, bool padding) {
    /**
    Spiegazione:
        snprintf(NULL, 0, ...) serve a calcolare quanto spazio occupa il suffisso ".%02d]:".
        nameMaxLen è quanto resta per il nome, togliendo:
            1 per [ iniziale,
            pinLen per il suffisso ".XX]:"
        Il formato "%.*s" tronca name automaticamente alla lunghezza massima disponibile.
    */

    int pinLen = snprintf(NULL, 0, ".%02d]", pin);
    printf("pinLen: %d\n", pinLen);
    // size_t nameMaxLen = (MAXLENGTH > (size_t)(pinLen + 1)) ? (MAXLENGTH - (pinLen + 1)) : 0;
    size_t nameMaxLen = (MAXLENGTH > (size_t)(pinLen)) ? (MAXLENGTH - (pinLen )) : 0;
    printf("nameMaxLen: %d\n", (int)nameMaxLen);

    if (padding) {
        // Creazione stringa con padding (spazi a destra)
        snprintf(buffer, MAXLENGTH, "[%-*.*s.%02d]", (int)nameMaxLen, (int)nameMaxLen, name, pin);
    } else {
        snprintf(buffer, MAXLENGTH, "[%.*s.%02d]", (int)nameMaxLen, name, pin);
    }

}
#endif




#if 0
void setPinID1(char buffer[], int MAXLENGTH, const char *name, int pin, bool padding) {
    /**
    Spiegazione:
        snprintf(NULL, 0, ...) serve a calcolare quanto spazio occupa il suffisso ".%02d]:".
        nameMaxLen è quanto resta per il nome, togliendo:
            1 per [ iniziale,
            pinLen per il suffisso ".XX]:"
        Il formato "%.*s" tronca name automaticamente alla lunghezza massima disponibile.
    */
    padding=false; // NON implemetato
    int pinLen = snprintf(NULL, 0, ".%02d]", pin);
    int nameMaxLen = MAXLENGTH - (pinLen);
    printf99_NFN("MAXLENGTH: %d\n", (int)MAXLENGTH);
    printf99_NFN("nameMaxLen: %d\n", (int)nameMaxLen);
    printf99_NFN("pinLen: %d\n", (int)pinLen);
    // int rest = nameMaxLen;
    char *p = buffer;

    // copiamo il name nel buffer....
    int inx=0;
    *p++ = '[';
    for (; name[inx]!='\0' && nameMaxLen>0;  inx++, nameMaxLen--) {
        *p++=name[inx];
    }
    // *p=0; // close string solo per debug per stampare buffer
    snprintf(buffer+inx, pinLen+1, ".%02d]", pin); // maxlen include anche lo \0 finale
    //snprintf(--p, pinLen+1, ".%02d]", pin);

}
#define printf99_NFN printf

void setPinID2(char buffer[], int MAXLENGTH, const char *name, int pin, const char prefix, const char suffix, bool padding) {
    /**
    Spiegazione:
        snprintf(NULL, 0, ...) serve a calcolare quanto spazio occupa il suffisso ".%02d]:".
        nameMaxLen è quanto resta per il nome, togliendo:
            1 per [ iniziale,
            pinLen per il suffisso ".XX]:"
        Il formato "%.*s" tronca name automaticamente alla lunghezza massima disponibile.
    */
    padding=false; // NON implemetato
    const char *pinFmt=".%02d";
    char pinSuffix[8];
    int pinLen = snprintf(pinSuffix, sizeof(pinSuffix), pinFmt, pin);
    //snprintf(buffer, MAXLENGTH, "%.*s", (int)nameMaxLen, name);


    //const char pinStr = snprintf(NULL, 0, pinFmt, pin);
    //int pinLen = snprintf(NULL, 0, pinFmt, pin);

    int nameMaxLen = MAXLENGTH - (pinLen);
    printf99_NFN("MAXLENGTH: %d\n", (int)MAXLENGTH);
    printf99_NFN("nameMaxLen: %d\n", (int)nameMaxLen);
    printf99_NFN("pinLen: %d\n", (int)pinLen);

    int index = snprintf(buffer, MAXLENGTH, "%.*s", (int)nameMaxLen, name);
    // printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));
    // printf99_NFN("index: %d\n", (int)index);
    index = snprintf(buffer+index, pinLen+1, "%s", pinSuffix);
    printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));


    index = snprintf(buffer, MAXLENGTH, "%.*s", (int)nameMaxLen, name);
    // printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));
    // printf99_NFN("index: %d\n", (int)index);
    index = snprintf(buffer+index, pinLen+1, ".%02d", pin);
    printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));



    //-- manca un carattere non capisco!!!
    snprintf(buffer, MAXLENGTH, "%.*s.%02d", (int)nameMaxLen-1, name, pin);
}



void setPinID_OK(char buffer[], int MAXLENGTH, const char *name, int pin, bool padding) {
    /**
    Spiegazione:
        snprintf(NULL, 0, ...) serve a calcolare quanto spazio occupa il suffisso ".%02d]:".
        nameMaxLen è quanto resta per il nome, togliendo:
            1 per [ iniziale,
            pinLen per il suffisso ".XX]:"
        Il formato "%.*s" tronca name automaticamente alla lunghezza massima disponibile.
    */
    padding=false; // NON implemetato


    // const char pinStr = snprintf(NULL, 0, pinFmt, pin);
    int pinLen = snprintf(NULL, 0, ".%02d", pin);

    int nameMaxLen = MAXLENGTH - (pinLen);
    printf99_NFN("MAXLENGTH: %d\n", (int)MAXLENGTH);
    printf99_NFN("nameMaxLen: %d\n", (int)nameMaxLen);
    printf99_NFN("pinLen: %d\n", (int)pinLen);



    int index = snprintf(buffer, MAXLENGTH, "%.*s", (int)nameMaxLen, name);
    // printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));
    // printf99_NFN("index: %d\n", (int)index);
    index = snprintf(buffer+index, pinLen+1, ".%02d", pin);
    printf("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));



    //-- manca un carattere non capisco!!!
    snprintf(buffer, MAXLENGTH, "%.*s%d", (int)nameMaxLen-1, name, pin);
}

void setPinID_OK1(char buffer[], int MAXLENGTH, const char *name, int pin) {

    int pinLen = snprintf(NULL, 0, ".%02d", pin); // calcolo lunghezza

    int nameMaxLen = MAXLENGTH - (pinLen);
    printf99_NFN("MAXLENGTH: %d\n", (int)MAXLENGTH);
    printf99_NFN("nameMaxLen: %d\n", (int)nameMaxLen);
    printf99_NFN("pinLen: %d\n", (int)pinLen);

    //-- manca un carattere non capisco!!!
    // snprintf(buffer, MAXLENGTH, "[%.*s.%2d]", (int)nameMaxLen-3, name, pin);

    //... allora spezziamo il processo... prima il nome (maxNameLen-1 per '[')
    int index = snprintf(buffer, MAXLENGTH, "[%.*s", (int)nameMaxLen-1, name);
    printf99_NFN("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));

    //... po il pin
    index = snprintf(buffer+index, pinLen+1, ".%2d]", pin);
    printf99_NFN("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));

}
#endif


const char* setFnameLine(char buffer[], int MAXLENGTH, const char *path, int lineNo) {

    // create string with lineNo
    static char lineSuffix[8];
    int lineNo_len = snprintf(lineSuffix, sizeof(lineSuffix), ".%03d]", lineNo);
    size_t nameMaxLen = (MAXLENGTH > (lineNo_len)) ? (MAXLENGTH - (lineNo_len )) : 0;

    // Estrai il nome file senza path
    const char *basename = strrchr(path, '/');
    basename = (basename) ? basename + 1 : path;  // se non c'è '/', usa tutto

    // Rimuovi estensione (se presente)
    size_t len = strcspn(basename, ".");  // lunghezza fino al primo '.'

    // Aggiustiamo maxNameLen
    nameMaxLen = ((len < nameMaxLen) ? len : nameMaxLen);


    printf99_NFN("MAXLENGTH: %d\n", (int)MAXLENGTH);
    printf99_NFN("nameMaxLen: %d\n", (int)nameMaxLen);
    printf99_NFN("lineNo_len: %d\n", (int)lineNo_len);

    //... prima i nome
    int index = snprintf(buffer, MAXLENGTH, "[%.*s", (int)nameMaxLen-1, basename);
    printf99_NFN("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));

    //... poi la line
    index = snprintf(buffer+index, lineNo_len+1, "%s", lineSuffix);
    printf99_NFN("buffer: <%s> len: %d\n", buffer, (int)strlen(buffer));
    // return &buffer[0];
    return buffer;
}



#if 0
int main() {
    printf("Hello World\n");
    char pinID[16]; // name_len + 1 + 6+2
    const size_t MAXLENGTH = sizeof(pinID)-1;
    printf("MAXLENGTH: %d\n", (int)MAXLENGTH);
    setPinID(pinID, MAXLENGTH, "123456789012345678901234567890", 10, false);
    printf("pinID: <%s> len: %d\n", pinID, (int)strlen(pinID));
    if (strlen(pinID) > MAXLENGTH) {
        printf("ERRORE: lunghezza superata\n");
    }

    formatFnameLine(pinID, MAXLENGTH, "/home/loreto/123456789012345678901234567890txt", 67, false);
    printf("pinID: <%s> len: %d\n", pinID, (int)strlen(pinID));
    if (strlen(pinID) > MAXLENGTH) {
        printf("ERRORE: lunghezza superata\n");
    }

    formatNamePin(pinID, MAXLENGTH, "123456789012345678901234567890", 10, false);
    printf("pinID: <%s> len: %d\n", pinID, (int)strlen(pinID));
    if (strlen(pinID) > MAXLENGTH) {
        printf("ERRORE: lunghezza superata\n");
    }

    return 0;
#endif

